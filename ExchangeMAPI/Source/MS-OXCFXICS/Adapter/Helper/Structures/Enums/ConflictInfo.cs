//-----------------------------------------------------------------------
// Copyright (c) 2014 Microsoft Corporation. All rights reserved.
// Use of this sample source code is subject to the terms of the Microsoft license 
// agreement under which you licensed this sample source code and is provided AS-IS.
// If you did not accept the terms of the license agreement, you are not authorized 
// to use this sample source code. For the terms of the license, please see the 
// license agreement between you and Microsoft.
//-----------------------------------------------------------------------

namespace Microsoft.Protocols.TestSuites.MS_OXCFXICS
{
    using System;

    /// <summary>
    /// The type of conflict generated when call import*, all the detail refer to the MS-OXFXICS
    /// </summary>
    [Flags]
    public enum ConflictTypes
    {
        /// <summary>
        /// Don't need conflict detected.
        /// </summary>
        NONE = 0x00,

        /// <summary>
        /// PCLA include PCLB. 
        /// </summary>
        AINCLUDEB = 0x01,

        /// <summary>
        /// PCLB include PCLA.
        /// </summary>
        BINCLUDEA = 0x02,

        /// <summary>
        /// Neither PCLA include PCLB nor PCLB include PCLA.
        /// </summary>
        CONFLICT = 0x04
    }

    /// <summary>
    /// The last conflict info generated when the last call import*
    /// </summary>
    public class ConflictInfo
    {
        /// <summary>
        /// The PCLA from the client.
        /// </summary>
        private byte[] pcla;

        /// <summary>
        /// The PCLB from the client.
        /// </summary>
        private byte[] pclb;
        
        /// <summary>
        /// The PCLX from the server.
        /// </summary>
        private byte[] pclXFromServer;
        
        /// <summary>
        /// The PCLX generate by math.
        /// </summary>
        private byte[] pclXFromMath;

        /// <summary>
        /// Gets or sets the conflict type when detected between PCLA and PCLB.
        /// </summary>
        public ConflictTypes DetectedResult { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether the record of the last conflict detect object is a FAI message
        /// </summary>
        public bool IsFAIMessage { get; set; }

        /// <summary>
        /// Gets or sets the PCLA from the client.
        /// </summary>
        public byte[] PCLA
        {
            get
            {
                return this.pcla;
            }

            set 
            {
                if (this.pcla == null || this.pcla.Length != value.Length)
                {
                    this.pcla = new byte[value.Length];
                }

                Array.Copy(value, this.pcla, value.Length);
            }
        }

        /// <summary>
        /// Gets or sets the PCLB from the server.
        /// </summary>
        public byte[] PCLB
        {
            get 
            {
                return this.pclb;
            }

            set
            {
                if (this.pclb == null || this.pclb.Length != value.Length)
                {
                    this.pclb = new byte[value.Length];
                }

                Array.Copy(value, this.pclb, value.Length);
            }
        }

        /// <summary>
        /// Gets or sets the PCLX from the server as the conflict result.
        /// </summary>
        public byte[] PCLXFromServer
        {
            get 
            {
                return this.pclXFromServer; 
            }

            set
            {
                if (this.pclXFromServer == null || this.pclXFromServer.Length != value.Length)
                {
                    this.pclXFromServer = new byte[value.Length];
                }

                Array.Copy(value, this.pclXFromServer, value.Length);
            }
        }

        /// <summary>
        /// Gets or sets the PCLX generated by analysis the PCLA and PCLB
        /// </summary>
        public byte[] PCLXFromMath
        {
            get
            {
                return this.pclXFromMath; 
            }

            set
            {
                if (this.pclXFromMath == null || this.pclXFromMath.Length != value.Length)
                {
                    this.pclXFromMath = new byte[value.Length];
                }

                Array.Copy(value, this.pclXFromMath, value.Length);
            }
        }

        /// <summary>
        /// Check the PCLA and PCLB detect conflict of the object.
        /// </summary>
        /// <returns>Indicate the conflict check result.</returns>
        public bool? CheckResult()
        {
            bool? result = null;
            if (this.PCLA != null && this.PCLB != null && this.PCLXFromMath != null && this.PCLXFromServer != null)
            {
                result = true;
                int pclHeadLength = 2;
                int xidLength = 23;
                if ((this.PCLXFromMath.Length - pclHeadLength) / xidLength == this.PCLXFromServer.Length / 23)
                {
                    for (int i = 2; i < this.PCLXFromMath.Length; i++)
                    {
                        if (this.PCLXFromMath[i] != this.PCLXFromServer[i - 2])
                        {
                            result = false;
                            break;
                        }
                    }
                }
                else
                {
                    result = false;
                }
            }

            return result;
        }
    }
}